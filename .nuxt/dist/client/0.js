(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[0],{

/***/ "./node_modules/image-meta/dist/index.mjs":
/*!************************************************!*\
  !*** ./node_modules/image-meta/dist/index.mjs ***!
  \************************************************/
/*! exports provided: imageMeta, types */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(Buffer) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"imageMeta\", function() { return imageMeta; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"types\", function() { return types; });\nconst BMP = {\n  validate(buffer) {\n    return buffer.toString(\"ascii\", 0, 2) === \"BM\";\n  },\n  calculate(buffer) {\n    return {\n      height: Math.abs(buffer.readInt32LE(22)),\n      width: buffer.readUInt32LE(18)\n    };\n  }\n};\n\nconst TYPE_ICON = 1;\nconst SIZE_HEADER$1 = 2 + 2 + 2;\nconst SIZE_IMAGE_ENTRY = 1 + 1 + 1 + 1 + 2 + 2 + 4 + 4;\nfunction getSizeFromOffset(buffer, offset) {\n  const value = buffer.readUInt8(offset);\n  return value === 0 ? 256 : value;\n}\nfunction getImageSize$1(buffer, imageIndex) {\n  const offset = SIZE_HEADER$1 + imageIndex * SIZE_IMAGE_ENTRY;\n  return {\n    height: getSizeFromOffset(buffer, offset + 1),\n    width: getSizeFromOffset(buffer, offset)\n  };\n}\nconst ICO = {\n  validate(buffer) {\n    if (buffer.readUInt16LE(0) !== 0) {\n      return false;\n    }\n    return buffer.readUInt16LE(2) === TYPE_ICON;\n  },\n  calculate(buffer) {\n    const nbImages = buffer.readUInt16LE(4);\n    const imageSize = getImageSize$1(buffer, 0);\n    if (nbImages === 1) {\n      return imageSize;\n    }\n    const imgs = [imageSize];\n    for (let imageIndex = 1; imageIndex < nbImages; imageIndex += 1) {\n      imgs.push(getImageSize$1(buffer, imageIndex));\n    }\n    const result = {\n      height: imageSize.height,\n      images: imgs,\n      width: imageSize.width\n    };\n    return result;\n  }\n};\n\nconst TYPE_CURSOR = 2;\nconst CUR = {\n  validate(buffer) {\n    if (buffer.readUInt16LE(0) !== 0) {\n      return false;\n    }\n    return buffer.readUInt16LE(2) === TYPE_CURSOR;\n  },\n  calculate(buffer) {\n    return ICO.calculate(buffer);\n  }\n};\n\nconst DDS = {\n  validate(buffer) {\n    return buffer.readUInt32LE(0) === 542327876;\n  },\n  calculate(buffer) {\n    return {\n      height: buffer.readUInt32LE(12),\n      width: buffer.readUInt32LE(16)\n    };\n  }\n};\n\nconst gifRegexp = /^GIF8[79]a/;\nconst GIF = {\n  validate(buffer) {\n    const signature = buffer.toString(\"ascii\", 0, 6);\n    return gifRegexp.test(signature);\n  },\n  calculate(buffer) {\n    return {\n      height: buffer.readUInt16LE(8),\n      width: buffer.readUInt16LE(6)\n    };\n  }\n};\n\nconst SIZE_HEADER = 4 + 4;\nconst FILE_LENGTH_OFFSET = 4;\nconst ENTRY_LENGTH_OFFSET = 4;\nconst ICON_TYPE_SIZE = {\n  ICON: 32,\n  \"ICN#\": 32,\n  \"icm#\": 16,\n  icm4: 16,\n  icm8: 16,\n  \"ics#\": 16,\n  ics4: 16,\n  ics8: 16,\n  is32: 16,\n  s8mk: 16,\n  icp4: 16,\n  icl4: 32,\n  icl8: 32,\n  il32: 32,\n  l8mk: 32,\n  icp5: 32,\n  ic11: 32,\n  ich4: 48,\n  ich8: 48,\n  ih32: 48,\n  h8mk: 48,\n  icp6: 64,\n  ic12: 32,\n  it32: 128,\n  t8mk: 128,\n  ic07: 128,\n  ic08: 256,\n  ic13: 256,\n  ic09: 512,\n  ic14: 512,\n  ic10: 1024\n};\nfunction readImageHeader(buffer, imageOffset) {\n  const imageLengthOffset = imageOffset + ENTRY_LENGTH_OFFSET;\n  return [\n    buffer.toString(\"ascii\", imageOffset, imageLengthOffset),\n    buffer.readUInt32BE(imageLengthOffset)\n  ];\n}\nfunction getImageSize(type) {\n  const size = ICON_TYPE_SIZE[type];\n  return { width: size, height: size, type };\n}\nconst ICNS = {\n  validate(buffer) {\n    return buffer.toString(\"ascii\", 0, 4) === \"icns\";\n  },\n  calculate(buffer) {\n    const bufferLength = buffer.length;\n    const fileLength = buffer.readUInt32BE(FILE_LENGTH_OFFSET);\n    let imageOffset = SIZE_HEADER;\n    let imageHeader = readImageHeader(buffer, imageOffset);\n    let imageSize = getImageSize(imageHeader[0]);\n    imageOffset += imageHeader[1];\n    if (imageOffset === fileLength) {\n      return imageSize;\n    }\n    const result = {\n      height: imageSize.height,\n      images: [imageSize],\n      width: imageSize.width\n    };\n    while (imageOffset < fileLength && imageOffset < bufferLength) {\n      imageHeader = readImageHeader(buffer, imageOffset);\n      imageSize = getImageSize(imageHeader[0]);\n      imageOffset += imageHeader[1];\n      result.images.push(imageSize);\n    }\n    return result;\n  }\n};\n\nconst J2C = {\n  validate(buffer) {\n    return buffer.toString(\"hex\", 0, 4) === \"ff4fff51\";\n  },\n  calculate(buffer) {\n    return {\n      height: buffer.readUInt32BE(12),\n      width: buffer.readUInt32BE(8)\n    };\n  }\n};\n\nconst BoxTypes = {\n  ftyp: \"66747970\",\n  ihdr: \"69686472\",\n  jp2h: \"6a703268\",\n  jp__: \"6a502020\",\n  rreq: \"72726571\",\n  xml_: \"786d6c20\"\n};\nconst calculateRREQLength = (box) => {\n  const unit = box.readUInt8(0);\n  let offset = 1 + 2 * unit;\n  const numStdFlags = box.readUInt16BE(offset);\n  const flagsLength = numStdFlags * (2 + unit);\n  offset = offset + 2 + flagsLength;\n  const numVendorFeatures = box.readUInt16BE(offset);\n  const featuresLength = numVendorFeatures * (16 + unit);\n  return offset + 2 + featuresLength;\n};\nconst parseIHDR = (box) => {\n  return {\n    height: box.readUInt32BE(4),\n    width: box.readUInt32BE(8)\n  };\n};\nconst JP2 = {\n  validate(buffer) {\n    const signature = buffer.toString(\"hex\", 4, 8);\n    const signatureLength = buffer.readUInt32BE(0);\n    if (signature !== BoxTypes.jp__ || signatureLength < 1) {\n      return false;\n    }\n    const ftypeBoxStart = signatureLength + 4;\n    const ftypBoxLength = buffer.readUInt32BE(signatureLength);\n    const ftypBox = buffer.slice(ftypeBoxStart, ftypeBoxStart + ftypBoxLength);\n    return ftypBox.toString(\"hex\", 0, 4) === BoxTypes.ftyp;\n  },\n  calculate(buffer) {\n    const signatureLength = buffer.readUInt32BE(0);\n    const ftypBoxLength = buffer.readUInt16BE(signatureLength + 2);\n    let offset = signatureLength + 4 + ftypBoxLength;\n    const nextBoxType = buffer.toString(\"hex\", offset, offset + 4);\n    switch (nextBoxType) {\n      case BoxTypes.rreq:\n        const MAGIC = 4;\n        offset = offset + 4 + MAGIC + calculateRREQLength(buffer.slice(offset + 4));\n        return parseIHDR(buffer.slice(offset + 8, offset + 24));\n      case BoxTypes.jp2h:\n        return parseIHDR(buffer.slice(offset + 8, offset + 24));\n      default:\n        throw new TypeError(\"Unsupported header found: \" + buffer.toString(\"ascii\", offset, offset + 4));\n    }\n  }\n};\n\nfunction readUInt(buffer, bits, offset, isBigEndian) {\n  offset = offset || 0;\n  const endian = isBigEndian ? \"BE\" : \"LE\";\n  const methodName = \"readUInt\" + bits + endian;\n  return buffer[methodName].call(buffer, offset);\n}\n\nconst EXIF_MARKER = \"45786966\";\nconst APP1_DATA_SIZE_BYTES = 2;\nconst EXIF_HEADER_BYTES = 6;\nconst TIFF_BYTE_ALIGN_BYTES = 2;\nconst BIG_ENDIAN_BYTE_ALIGN = \"4d4d\";\nconst LITTLE_ENDIAN_BYTE_ALIGN = \"4949\";\nconst IDF_ENTRY_BYTES = 12;\nconst NUM_DIRECTORY_ENTRIES_BYTES = 2;\nfunction isEXIF(buffer) {\n  return buffer.toString(\"hex\", 2, 6) === EXIF_MARKER;\n}\nfunction extractSize(buffer, index) {\n  return {\n    height: buffer.readUInt16BE(index),\n    width: buffer.readUInt16BE(index + 2)\n  };\n}\nfunction extractOrientation(exifBlock, isBigEndian) {\n  const idfOffset = 8;\n  const offset = EXIF_HEADER_BYTES + idfOffset;\n  const idfDirectoryEntries = readUInt(exifBlock, 16, offset, isBigEndian);\n  for (let directoryEntryNumber = 0; directoryEntryNumber < idfDirectoryEntries; directoryEntryNumber++) {\n    const start = offset + NUM_DIRECTORY_ENTRIES_BYTES + directoryEntryNumber * IDF_ENTRY_BYTES;\n    const end = start + IDF_ENTRY_BYTES;\n    if (start > exifBlock.length) {\n      return;\n    }\n    const block = exifBlock.slice(start, end);\n    const tagNumber = readUInt(block, 16, 0, isBigEndian);\n    if (tagNumber === 274) {\n      const dataFormat = readUInt(block, 16, 2, isBigEndian);\n      if (dataFormat !== 3) {\n        return;\n      }\n      const numberOfComponents = readUInt(block, 32, 4, isBigEndian);\n      if (numberOfComponents !== 1) {\n        return;\n      }\n      return readUInt(block, 16, 8, isBigEndian);\n    }\n  }\n}\nfunction validateExifBlock(buffer, index) {\n  const exifBlock = buffer.slice(APP1_DATA_SIZE_BYTES, index);\n  const byteAlign = exifBlock.toString(\"hex\", EXIF_HEADER_BYTES, EXIF_HEADER_BYTES + TIFF_BYTE_ALIGN_BYTES);\n  const isBigEndian = byteAlign === BIG_ENDIAN_BYTE_ALIGN;\n  const isLittleEndian = byteAlign === LITTLE_ENDIAN_BYTE_ALIGN;\n  if (isBigEndian || isLittleEndian) {\n    return extractOrientation(exifBlock, isBigEndian);\n  }\n}\nfunction validateBuffer(buffer, index) {\n  if (index > buffer.length) {\n    throw new TypeError(\"Corrupt JPG, exceeded buffer limits\");\n  }\n  if (buffer[index] !== 255) {\n    throw new TypeError(\"Invalid JPG, marker table corrupted\");\n  }\n}\nconst JPG = {\n  validate(buffer) {\n    const SOIMarker = buffer.toString(\"hex\", 0, 2);\n    return SOIMarker === \"ffd8\";\n  },\n  calculate(buffer) {\n    buffer = buffer.slice(4);\n    let orientation;\n    let next;\n    while (buffer.length) {\n      const i = buffer.readUInt16BE(0);\n      if (isEXIF(buffer)) {\n        orientation = validateExifBlock(buffer, i);\n      }\n      validateBuffer(buffer, i);\n      next = buffer[i + 1];\n      if (next === 192 || next === 193 || next === 194) {\n        const size = extractSize(buffer, i + 5);\n        if (!orientation) {\n          return size;\n        }\n        return {\n          height: size.height,\n          orientation,\n          width: size.width\n        };\n      }\n      buffer = buffer.slice(i + 2);\n    }\n    throw new TypeError(\"Invalid JPG, no size found\");\n  }\n};\n\nconst SIGNATURE = \"KTX 11\";\nconst KTX = {\n  validate(buffer) {\n    return SIGNATURE === buffer.toString(\"ascii\", 1, 7);\n  },\n  calculate(buffer) {\n    return {\n      height: buffer.readUInt32LE(40),\n      width: buffer.readUInt32LE(36)\n    };\n  }\n};\n\nconst pngSignature = \"PNG\\r\\n\u001a\\n\";\nconst pngImageHeaderChunkName = \"IHDR\";\nconst pngFriedChunkName = \"CgBI\";\nconst PNG = {\n  validate(buffer) {\n    if (pngSignature === buffer.toString(\"ascii\", 1, 8)) {\n      let chunkName = buffer.toString(\"ascii\", 12, 16);\n      if (chunkName === pngFriedChunkName) {\n        chunkName = buffer.toString(\"ascii\", 28, 32);\n      }\n      if (chunkName !== pngImageHeaderChunkName) {\n        throw new TypeError(\"Invalid PNG\");\n      }\n      return true;\n    }\n    return false;\n  },\n  calculate(buffer) {\n    if (buffer.toString(\"ascii\", 12, 16) === pngFriedChunkName) {\n      return {\n        height: buffer.readUInt32BE(36),\n        width: buffer.readUInt32BE(32)\n      };\n    }\n    return {\n      height: buffer.readUInt32BE(20),\n      width: buffer.readUInt32BE(16)\n    };\n  }\n};\n\nconst PNMTypes = {\n  P1: \"pbm/ascii\",\n  P2: \"pgm/ascii\",\n  P3: \"ppm/ascii\",\n  P4: \"pbm\",\n  P5: \"pgm\",\n  P6: \"ppm\",\n  P7: \"pam\",\n  PF: \"pfm\"\n};\nconst Signatures = Object.keys(PNMTypes);\nconst handlers = {\n  default: (lines) => {\n    let dimensions = [];\n    while (lines.length > 0) {\n      const line = lines.shift();\n      if (line[0] === \"#\") {\n        continue;\n      }\n      dimensions = line.split(\" \");\n      break;\n    }\n    if (dimensions.length === 2) {\n      return {\n        height: parseInt(dimensions[1], 10),\n        width: parseInt(dimensions[0], 10)\n      };\n    } else {\n      throw new TypeError(\"Invalid PNM\");\n    }\n  },\n  pam: (lines) => {\n    const size = {};\n    while (lines.length > 0) {\n      const line = lines.shift();\n      if (line.length > 16 || line.charCodeAt(0) > 128) {\n        continue;\n      }\n      const [key, value] = line.split(\" \");\n      if (key && value) {\n        size[key.toLowerCase()] = parseInt(value, 10);\n      }\n      if (size.height && size.width) {\n        break;\n      }\n    }\n    if (size.height && size.width) {\n      return {\n        height: size.height,\n        width: size.width\n      };\n    } else {\n      throw new TypeError(\"Invalid PAM\");\n    }\n  }\n};\nconst PNM = {\n  validate(buffer) {\n    const signature = buffer.toString(\"ascii\", 0, 2);\n    return Signatures.includes(signature);\n  },\n  calculate(buffer) {\n    const signature = buffer.toString(\"ascii\", 0, 2);\n    const type = PNMTypes[signature];\n    const lines = buffer.toString(\"ascii\", 3).split(/[\\r\\n]+/);\n    const handler = handlers[type] || handlers.default;\n    return handler(lines);\n  }\n};\n\nconst PSD = {\n  validate(buffer) {\n    return buffer.toString(\"ascii\", 0, 4) === \"8BPS\";\n  },\n  calculate(buffer) {\n    return {\n      height: buffer.readUInt32BE(14),\n      width: buffer.readUInt32BE(18)\n    };\n  }\n};\n\nconst svgReg = /<svg\\s([^>\"']|\"[^\"]*\"|'[^']*')*>/;\nconst extractorRegExps = {\n  height: /\\sheight=(['\"])([^%]+?)\\1/,\n  root: svgReg,\n  viewbox: /\\sviewBox=(['\"])(.+?)\\1/,\n  width: /\\swidth=(['\"])([^%]+?)\\1/\n};\nconst INCH_CM = 2.54;\nconst units = {\n  cm: 96 / INCH_CM,\n  em: 16,\n  ex: 8,\n  m: 96 / INCH_CM * 100,\n  mm: 96 / INCH_CM / 10,\n  pc: 96 / 72 / 12,\n  pt: 96 / 72\n};\nfunction parseLength(len) {\n  const m = /([0-9.]+)([a-z]*)/.exec(len);\n  if (!m) {\n    return void 0;\n  }\n  return Math.round(parseFloat(m[1]) * (units[m[2]] || 1));\n}\nfunction parseViewbox(viewbox) {\n  const bounds = viewbox.split(\" \");\n  return {\n    height: parseLength(bounds[3]),\n    width: parseLength(bounds[2])\n  };\n}\nfunction parseAttributes(root) {\n  const width = root.match(extractorRegExps.width);\n  const height = root.match(extractorRegExps.height);\n  const viewbox = root.match(extractorRegExps.viewbox);\n  return {\n    height: height && parseLength(height[2]),\n    viewbox: viewbox && parseViewbox(viewbox[2]),\n    width: width && parseLength(width[2])\n  };\n}\nfunction calculateByDimensions(attrs) {\n  return {\n    height: attrs.height,\n    width: attrs.width\n  };\n}\nfunction calculateByViewbox(attrs, viewbox) {\n  const ratio = viewbox.width / viewbox.height;\n  if (attrs.width) {\n    return {\n      height: Math.floor(attrs.width / ratio),\n      width: attrs.width\n    };\n  }\n  if (attrs.height) {\n    return {\n      height: attrs.height,\n      width: Math.floor(attrs.height * ratio)\n    };\n  }\n  return {\n    height: viewbox.height,\n    width: viewbox.width\n  };\n}\nconst SVG = {\n  validate(buffer) {\n    const str = String(buffer);\n    return svgReg.test(str);\n  },\n  calculate(buffer) {\n    const root = buffer.toString(\"utf8\").match(extractorRegExps.root);\n    if (root) {\n      const attrs = parseAttributes(root[0]);\n      if (attrs.width && attrs.height) {\n        return calculateByDimensions(attrs);\n      }\n      if (attrs.viewbox) {\n        return calculateByViewbox(attrs, attrs.viewbox);\n      }\n    }\n    throw new TypeError(\"Invalid SVG\");\n  }\n};\n\nfunction calculateExtended(buffer) {\n  return {\n    height: 1 + buffer.readUIntLE(7, 3),\n    width: 1 + buffer.readUIntLE(4, 3)\n  };\n}\nfunction calculateLossless(buffer) {\n  return {\n    height: 1 + ((buffer[4] & 15) << 10 | buffer[3] << 2 | (buffer[2] & 192) >> 6),\n    width: 1 + ((buffer[2] & 63) << 8 | buffer[1])\n  };\n}\nfunction calculateLossy(buffer) {\n  return {\n    height: buffer.readInt16LE(8) & 16383,\n    width: buffer.readInt16LE(6) & 16383\n  };\n}\nconst WEBP = {\n  validate(buffer) {\n    const riffHeader = buffer.toString(\"ascii\", 0, 4) === \"RIFF\";\n    const webpHeader = buffer.toString(\"ascii\", 8, 12) === \"WEBP\";\n    const vp8Header = buffer.toString(\"ascii\", 12, 15) === \"VP8\";\n    return riffHeader && webpHeader && vp8Header;\n  },\n  calculate(buffer) {\n    const chunkHeader = buffer.toString(\"ascii\", 12, 16);\n    buffer = buffer.slice(20, 30);\n    if (chunkHeader === \"VP8X\") {\n      const extendedHeader = buffer[0];\n      const validStart = (extendedHeader & 192) === 0;\n      const validEnd = (extendedHeader & 1) === 0;\n      if (validStart && validEnd) {\n        return calculateExtended(buffer);\n      } else {\n        throw new TypeError(\"Invalid WebP\");\n      }\n    }\n    if (chunkHeader === \"VP8 \" && buffer[0] !== 47) {\n      return calculateLossy(buffer);\n    }\n    const signature = buffer.toString(\"hex\", 3, 6);\n    if (chunkHeader === \"VP8L\" && signature !== \"9d012a\") {\n      return calculateLossless(buffer);\n    }\n    throw new TypeError(\"Invalid WebP\");\n  }\n};\n\nconst typeHandlers = {\n  bmp: BMP,\n  cur: CUR,\n  dds: DDS,\n  gif: GIF,\n  icns: ICNS,\n  ico: ICO,\n  j2c: J2C,\n  jp2: JP2,\n  jpg: JPG,\n  ktx: KTX,\n  png: PNG,\n  pnm: PNM,\n  psd: PSD,\n  svg: SVG,\n  webp: WEBP\n};\nconst getMimeType = (type) => {\n  if (type === \"svg\") {\n    return \"image/svg+xml\";\n  }\n  return `image/${type}`;\n};\n\nconst keys = Object.keys(typeHandlers);\nconst firstBytes = {\n  56: \"psd\",\n  66: \"bmp\",\n  68: \"dds\",\n  71: \"gif\",\n  73: \"tiff\",\n  77: \"tiff\",\n  82: \"webp\",\n  105: \"icns\",\n  137: \"png\",\n  255: \"jpg\"\n};\nfunction detector(buffer) {\n  const byte = buffer[0];\n  if (byte in firstBytes) {\n    const type = firstBytes[byte];\n    if (typeHandlers[type].validate(buffer)) {\n      return type;\n    }\n  }\n  const finder = (key) => typeHandlers[key].validate(buffer);\n  return keys.find(finder);\n}\n\nfunction lookup(buffer, filepath) {\n  const type = detector(buffer);\n  if (type && type in typeHandlers) {\n    const size = typeHandlers[type].calculate(buffer, filepath);\n    if (size !== void 0) {\n      size.type = type;\n      size.mimeType = getMimeType(type);\n      return size;\n    }\n  }\n  throw new TypeError(\"unsupported file type: \" + type + \" (file: \" + filepath + \")\");\n}\nfunction imageMeta(input) {\n  if (Buffer.isBuffer(input)) {\n    return lookup(input);\n  }\n  throw new Error(\"Input should be buffer!\");\n}\nconst types = Object.keys(typeHandlers);\n\n\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node-libs-browser/node_modules/buffer/index.js */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaW1hZ2UtbWV0YS9kaXN0L2luZGV4Lm1qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbWFnZS1tZXRhL2Rpc3QvaW5kZXgubWpzPzhkYjciXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgQk1QID0ge1xuICB2YWxpZGF0ZShidWZmZXIpIHtcbiAgICByZXR1cm4gYnVmZmVyLnRvU3RyaW5nKFwiYXNjaWlcIiwgMCwgMikgPT09IFwiQk1cIjtcbiAgfSxcbiAgY2FsY3VsYXRlKGJ1ZmZlcikge1xuICAgIHJldHVybiB7XG4gICAgICBoZWlnaHQ6IE1hdGguYWJzKGJ1ZmZlci5yZWFkSW50MzJMRSgyMikpLFxuICAgICAgd2lkdGg6IGJ1ZmZlci5yZWFkVUludDMyTEUoMTgpXG4gICAgfTtcbiAgfVxufTtcblxuY29uc3QgVFlQRV9JQ09OID0gMTtcbmNvbnN0IFNJWkVfSEVBREVSJDEgPSAyICsgMiArIDI7XG5jb25zdCBTSVpFX0lNQUdFX0VOVFJZID0gMSArIDEgKyAxICsgMSArIDIgKyAyICsgNCArIDQ7XG5mdW5jdGlvbiBnZXRTaXplRnJvbU9mZnNldChidWZmZXIsIG9mZnNldCkge1xuICBjb25zdCB2YWx1ZSA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgcmV0dXJuIHZhbHVlID09PSAwID8gMjU2IDogdmFsdWU7XG59XG5mdW5jdGlvbiBnZXRJbWFnZVNpemUkMShidWZmZXIsIGltYWdlSW5kZXgpIHtcbiAgY29uc3Qgb2Zmc2V0ID0gU0laRV9IRUFERVIkMSArIGltYWdlSW5kZXggKiBTSVpFX0lNQUdFX0VOVFJZO1xuICByZXR1cm4ge1xuICAgIGhlaWdodDogZ2V0U2l6ZUZyb21PZmZzZXQoYnVmZmVyLCBvZmZzZXQgKyAxKSxcbiAgICB3aWR0aDogZ2V0U2l6ZUZyb21PZmZzZXQoYnVmZmVyLCBvZmZzZXQpXG4gIH07XG59XG5jb25zdCBJQ08gPSB7XG4gIHZhbGlkYXRlKGJ1ZmZlcikge1xuICAgIGlmIChidWZmZXIucmVhZFVJbnQxNkxFKDApICE9PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBidWZmZXIucmVhZFVJbnQxNkxFKDIpID09PSBUWVBFX0lDT047XG4gIH0sXG4gIGNhbGN1bGF0ZShidWZmZXIpIHtcbiAgICBjb25zdCBuYkltYWdlcyA9IGJ1ZmZlci5yZWFkVUludDE2TEUoNCk7XG4gICAgY29uc3QgaW1hZ2VTaXplID0gZ2V0SW1hZ2VTaXplJDEoYnVmZmVyLCAwKTtcbiAgICBpZiAobmJJbWFnZXMgPT09IDEpIHtcbiAgICAgIHJldHVybiBpbWFnZVNpemU7XG4gICAgfVxuICAgIGNvbnN0IGltZ3MgPSBbaW1hZ2VTaXplXTtcbiAgICBmb3IgKGxldCBpbWFnZUluZGV4ID0gMTsgaW1hZ2VJbmRleCA8IG5iSW1hZ2VzOyBpbWFnZUluZGV4ICs9IDEpIHtcbiAgICAgIGltZ3MucHVzaChnZXRJbWFnZVNpemUkMShidWZmZXIsIGltYWdlSW5kZXgpKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgaGVpZ2h0OiBpbWFnZVNpemUuaGVpZ2h0LFxuICAgICAgaW1hZ2VzOiBpbWdzLFxuICAgICAgd2lkdGg6IGltYWdlU2l6ZS53aWR0aFxuICAgIH07XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcblxuY29uc3QgVFlQRV9DVVJTT1IgPSAyO1xuY29uc3QgQ1VSID0ge1xuICB2YWxpZGF0ZShidWZmZXIpIHtcbiAgICBpZiAoYnVmZmVyLnJlYWRVSW50MTZMRSgwKSAhPT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyLnJlYWRVSW50MTZMRSgyKSA9PT0gVFlQRV9DVVJTT1I7XG4gIH0sXG4gIGNhbGN1bGF0ZShidWZmZXIpIHtcbiAgICByZXR1cm4gSUNPLmNhbGN1bGF0ZShidWZmZXIpO1xuICB9XG59O1xuXG5jb25zdCBERFMgPSB7XG4gIHZhbGlkYXRlKGJ1ZmZlcikge1xuICAgIHJldHVybiBidWZmZXIucmVhZFVJbnQzMkxFKDApID09PSA1NDIzMjc4NzY7XG4gIH0sXG4gIGNhbGN1bGF0ZShidWZmZXIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaGVpZ2h0OiBidWZmZXIucmVhZFVJbnQzMkxFKDEyKSxcbiAgICAgIHdpZHRoOiBidWZmZXIucmVhZFVJbnQzMkxFKDE2KVxuICAgIH07XG4gIH1cbn07XG5cbmNvbnN0IGdpZlJlZ2V4cCA9IC9eR0lGOFs3OV1hLztcbmNvbnN0IEdJRiA9IHtcbiAgdmFsaWRhdGUoYnVmZmVyKSB7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gYnVmZmVyLnRvU3RyaW5nKFwiYXNjaWlcIiwgMCwgNik7XG4gICAgcmV0dXJuIGdpZlJlZ2V4cC50ZXN0KHNpZ25hdHVyZSk7XG4gIH0sXG4gIGNhbGN1bGF0ZShidWZmZXIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaGVpZ2h0OiBidWZmZXIucmVhZFVJbnQxNkxFKDgpLFxuICAgICAgd2lkdGg6IGJ1ZmZlci5yZWFkVUludDE2TEUoNilcbiAgICB9O1xuICB9XG59O1xuXG5jb25zdCBTSVpFX0hFQURFUiA9IDQgKyA0O1xuY29uc3QgRklMRV9MRU5HVEhfT0ZGU0VUID0gNDtcbmNvbnN0IEVOVFJZX0xFTkdUSF9PRkZTRVQgPSA0O1xuY29uc3QgSUNPTl9UWVBFX1NJWkUgPSB7XG4gIElDT046IDMyLFxuICBcIklDTiNcIjogMzIsXG4gIFwiaWNtI1wiOiAxNixcbiAgaWNtNDogMTYsXG4gIGljbTg6IDE2LFxuICBcImljcyNcIjogMTYsXG4gIGljczQ6IDE2LFxuICBpY3M4OiAxNixcbiAgaXMzMjogMTYsXG4gIHM4bWs6IDE2LFxuICBpY3A0OiAxNixcbiAgaWNsNDogMzIsXG4gIGljbDg6IDMyLFxuICBpbDMyOiAzMixcbiAgbDhtazogMzIsXG4gIGljcDU6IDMyLFxuICBpYzExOiAzMixcbiAgaWNoNDogNDgsXG4gIGljaDg6IDQ4LFxuICBpaDMyOiA0OCxcbiAgaDhtazogNDgsXG4gIGljcDY6IDY0LFxuICBpYzEyOiAzMixcbiAgaXQzMjogMTI4LFxuICB0OG1rOiAxMjgsXG4gIGljMDc6IDEyOCxcbiAgaWMwODogMjU2LFxuICBpYzEzOiAyNTYsXG4gIGljMDk6IDUxMixcbiAgaWMxNDogNTEyLFxuICBpYzEwOiAxMDI0XG59O1xuZnVuY3Rpb24gcmVhZEltYWdlSGVhZGVyKGJ1ZmZlciwgaW1hZ2VPZmZzZXQpIHtcbiAgY29uc3QgaW1hZ2VMZW5ndGhPZmZzZXQgPSBpbWFnZU9mZnNldCArIEVOVFJZX0xFTkdUSF9PRkZTRVQ7XG4gIHJldHVybiBbXG4gICAgYnVmZmVyLnRvU3RyaW5nKFwiYXNjaWlcIiwgaW1hZ2VPZmZzZXQsIGltYWdlTGVuZ3RoT2Zmc2V0KSxcbiAgICBidWZmZXIucmVhZFVJbnQzMkJFKGltYWdlTGVuZ3RoT2Zmc2V0KVxuICBdO1xufVxuZnVuY3Rpb24gZ2V0SW1hZ2VTaXplKHR5cGUpIHtcbiAgY29uc3Qgc2l6ZSA9IElDT05fVFlQRV9TSVpFW3R5cGVdO1xuICByZXR1cm4geyB3aWR0aDogc2l6ZSwgaGVpZ2h0OiBzaXplLCB0eXBlIH07XG59XG5jb25zdCBJQ05TID0ge1xuICB2YWxpZGF0ZShidWZmZXIpIHtcbiAgICByZXR1cm4gYnVmZmVyLnRvU3RyaW5nKFwiYXNjaWlcIiwgMCwgNCkgPT09IFwiaWNuc1wiO1xuICB9LFxuICBjYWxjdWxhdGUoYnVmZmVyKSB7XG4gICAgY29uc3QgYnVmZmVyTGVuZ3RoID0gYnVmZmVyLmxlbmd0aDtcbiAgICBjb25zdCBmaWxlTGVuZ3RoID0gYnVmZmVyLnJlYWRVSW50MzJCRShGSUxFX0xFTkdUSF9PRkZTRVQpO1xuICAgIGxldCBpbWFnZU9mZnNldCA9IFNJWkVfSEVBREVSO1xuICAgIGxldCBpbWFnZUhlYWRlciA9IHJlYWRJbWFnZUhlYWRlcihidWZmZXIsIGltYWdlT2Zmc2V0KTtcbiAgICBsZXQgaW1hZ2VTaXplID0gZ2V0SW1hZ2VTaXplKGltYWdlSGVhZGVyWzBdKTtcbiAgICBpbWFnZU9mZnNldCArPSBpbWFnZUhlYWRlclsxXTtcbiAgICBpZiAoaW1hZ2VPZmZzZXQgPT09IGZpbGVMZW5ndGgpIHtcbiAgICAgIHJldHVybiBpbWFnZVNpemU7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgIGhlaWdodDogaW1hZ2VTaXplLmhlaWdodCxcbiAgICAgIGltYWdlczogW2ltYWdlU2l6ZV0sXG4gICAgICB3aWR0aDogaW1hZ2VTaXplLndpZHRoXG4gICAgfTtcbiAgICB3aGlsZSAoaW1hZ2VPZmZzZXQgPCBmaWxlTGVuZ3RoICYmIGltYWdlT2Zmc2V0IDwgYnVmZmVyTGVuZ3RoKSB7XG4gICAgICBpbWFnZUhlYWRlciA9IHJlYWRJbWFnZUhlYWRlcihidWZmZXIsIGltYWdlT2Zmc2V0KTtcbiAgICAgIGltYWdlU2l6ZSA9IGdldEltYWdlU2l6ZShpbWFnZUhlYWRlclswXSk7XG4gICAgICBpbWFnZU9mZnNldCArPSBpbWFnZUhlYWRlclsxXTtcbiAgICAgIHJlc3VsdC5pbWFnZXMucHVzaChpbWFnZVNpemUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuXG5jb25zdCBKMkMgPSB7XG4gIHZhbGlkYXRlKGJ1ZmZlcikge1xuICAgIHJldHVybiBidWZmZXIudG9TdHJpbmcoXCJoZXhcIiwgMCwgNCkgPT09IFwiZmY0ZmZmNTFcIjtcbiAgfSxcbiAgY2FsY3VsYXRlKGJ1ZmZlcikge1xuICAgIHJldHVybiB7XG4gICAgICBoZWlnaHQ6IGJ1ZmZlci5yZWFkVUludDMyQkUoMTIpLFxuICAgICAgd2lkdGg6IGJ1ZmZlci5yZWFkVUludDMyQkUoOClcbiAgICB9O1xuICB9XG59O1xuXG5jb25zdCBCb3hUeXBlcyA9IHtcbiAgZnR5cDogXCI2Njc0Nzk3MFwiLFxuICBpaGRyOiBcIjY5Njg2NDcyXCIsXG4gIGpwMmg6IFwiNmE3MDMyNjhcIixcbiAganBfXzogXCI2YTUwMjAyMFwiLFxuICBycmVxOiBcIjcyNzI2NTcxXCIsXG4gIHhtbF86IFwiNzg2ZDZjMjBcIlxufTtcbmNvbnN0IGNhbGN1bGF0ZVJSRVFMZW5ndGggPSAoYm94KSA9PiB7XG4gIGNvbnN0IHVuaXQgPSBib3gucmVhZFVJbnQ4KDApO1xuICBsZXQgb2Zmc2V0ID0gMSArIDIgKiB1bml0O1xuICBjb25zdCBudW1TdGRGbGFncyA9IGJveC5yZWFkVUludDE2QkUob2Zmc2V0KTtcbiAgY29uc3QgZmxhZ3NMZW5ndGggPSBudW1TdGRGbGFncyAqICgyICsgdW5pdCk7XG4gIG9mZnNldCA9IG9mZnNldCArIDIgKyBmbGFnc0xlbmd0aDtcbiAgY29uc3QgbnVtVmVuZG9yRmVhdHVyZXMgPSBib3gucmVhZFVJbnQxNkJFKG9mZnNldCk7XG4gIGNvbnN0IGZlYXR1cmVzTGVuZ3RoID0gbnVtVmVuZG9yRmVhdHVyZXMgKiAoMTYgKyB1bml0KTtcbiAgcmV0dXJuIG9mZnNldCArIDIgKyBmZWF0dXJlc0xlbmd0aDtcbn07XG5jb25zdCBwYXJzZUlIRFIgPSAoYm94KSA9PiB7XG4gIHJldHVybiB7XG4gICAgaGVpZ2h0OiBib3gucmVhZFVJbnQzMkJFKDQpLFxuICAgIHdpZHRoOiBib3gucmVhZFVJbnQzMkJFKDgpXG4gIH07XG59O1xuY29uc3QgSlAyID0ge1xuICB2YWxpZGF0ZShidWZmZXIpIHtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBidWZmZXIudG9TdHJpbmcoXCJoZXhcIiwgNCwgOCk7XG4gICAgY29uc3Qgc2lnbmF0dXJlTGVuZ3RoID0gYnVmZmVyLnJlYWRVSW50MzJCRSgwKTtcbiAgICBpZiAoc2lnbmF0dXJlICE9PSBCb3hUeXBlcy5qcF9fIHx8IHNpZ25hdHVyZUxlbmd0aCA8IDEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgZnR5cGVCb3hTdGFydCA9IHNpZ25hdHVyZUxlbmd0aCArIDQ7XG4gICAgY29uc3QgZnR5cEJveExlbmd0aCA9IGJ1ZmZlci5yZWFkVUludDMyQkUoc2lnbmF0dXJlTGVuZ3RoKTtcbiAgICBjb25zdCBmdHlwQm94ID0gYnVmZmVyLnNsaWNlKGZ0eXBlQm94U3RhcnQsIGZ0eXBlQm94U3RhcnQgKyBmdHlwQm94TGVuZ3RoKTtcbiAgICByZXR1cm4gZnR5cEJveC50b1N0cmluZyhcImhleFwiLCAwLCA0KSA9PT0gQm94VHlwZXMuZnR5cDtcbiAgfSxcbiAgY2FsY3VsYXRlKGJ1ZmZlcikge1xuICAgIGNvbnN0IHNpZ25hdHVyZUxlbmd0aCA9IGJ1ZmZlci5yZWFkVUludDMyQkUoMCk7XG4gICAgY29uc3QgZnR5cEJveExlbmd0aCA9IGJ1ZmZlci5yZWFkVUludDE2QkUoc2lnbmF0dXJlTGVuZ3RoICsgMik7XG4gICAgbGV0IG9mZnNldCA9IHNpZ25hdHVyZUxlbmd0aCArIDQgKyBmdHlwQm94TGVuZ3RoO1xuICAgIGNvbnN0IG5leHRCb3hUeXBlID0gYnVmZmVyLnRvU3RyaW5nKFwiaGV4XCIsIG9mZnNldCwgb2Zmc2V0ICsgNCk7XG4gICAgc3dpdGNoIChuZXh0Qm94VHlwZSkge1xuICAgICAgY2FzZSBCb3hUeXBlcy5ycmVxOlxuICAgICAgICBjb25zdCBNQUdJQyA9IDQ7XG4gICAgICAgIG9mZnNldCA9IG9mZnNldCArIDQgKyBNQUdJQyArIGNhbGN1bGF0ZVJSRVFMZW5ndGgoYnVmZmVyLnNsaWNlKG9mZnNldCArIDQpKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlSUhEUihidWZmZXIuc2xpY2Uob2Zmc2V0ICsgOCwgb2Zmc2V0ICsgMjQpKTtcbiAgICAgIGNhc2UgQm94VHlwZXMuanAyaDpcbiAgICAgICAgcmV0dXJuIHBhcnNlSUhEUihidWZmZXIuc2xpY2Uob2Zmc2V0ICsgOCwgb2Zmc2V0ICsgMjQpKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbnN1cHBvcnRlZCBoZWFkZXIgZm91bmQ6IFwiICsgYnVmZmVyLnRvU3RyaW5nKFwiYXNjaWlcIiwgb2Zmc2V0LCBvZmZzZXQgKyA0KSk7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiByZWFkVUludChidWZmZXIsIGJpdHMsIG9mZnNldCwgaXNCaWdFbmRpYW4pIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gIGNvbnN0IGVuZGlhbiA9IGlzQmlnRW5kaWFuID8gXCJCRVwiIDogXCJMRVwiO1xuICBjb25zdCBtZXRob2ROYW1lID0gXCJyZWFkVUludFwiICsgYml0cyArIGVuZGlhbjtcbiAgcmV0dXJuIGJ1ZmZlclttZXRob2ROYW1lXS5jYWxsKGJ1ZmZlciwgb2Zmc2V0KTtcbn1cblxuY29uc3QgRVhJRl9NQVJLRVIgPSBcIjQ1Nzg2OTY2XCI7XG5jb25zdCBBUFAxX0RBVEFfU0laRV9CWVRFUyA9IDI7XG5jb25zdCBFWElGX0hFQURFUl9CWVRFUyA9IDY7XG5jb25zdCBUSUZGX0JZVEVfQUxJR05fQllURVMgPSAyO1xuY29uc3QgQklHX0VORElBTl9CWVRFX0FMSUdOID0gXCI0ZDRkXCI7XG5jb25zdCBMSVRUTEVfRU5ESUFOX0JZVEVfQUxJR04gPSBcIjQ5NDlcIjtcbmNvbnN0IElERl9FTlRSWV9CWVRFUyA9IDEyO1xuY29uc3QgTlVNX0RJUkVDVE9SWV9FTlRSSUVTX0JZVEVTID0gMjtcbmZ1bmN0aW9uIGlzRVhJRihidWZmZXIpIHtcbiAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZyhcImhleFwiLCAyLCA2KSA9PT0gRVhJRl9NQVJLRVI7XG59XG5mdW5jdGlvbiBleHRyYWN0U2l6ZShidWZmZXIsIGluZGV4KSB7XG4gIHJldHVybiB7XG4gICAgaGVpZ2h0OiBidWZmZXIucmVhZFVJbnQxNkJFKGluZGV4KSxcbiAgICB3aWR0aDogYnVmZmVyLnJlYWRVSW50MTZCRShpbmRleCArIDIpXG4gIH07XG59XG5mdW5jdGlvbiBleHRyYWN0T3JpZW50YXRpb24oZXhpZkJsb2NrLCBpc0JpZ0VuZGlhbikge1xuICBjb25zdCBpZGZPZmZzZXQgPSA4O1xuICBjb25zdCBvZmZzZXQgPSBFWElGX0hFQURFUl9CWVRFUyArIGlkZk9mZnNldDtcbiAgY29uc3QgaWRmRGlyZWN0b3J5RW50cmllcyA9IHJlYWRVSW50KGV4aWZCbG9jaywgMTYsIG9mZnNldCwgaXNCaWdFbmRpYW4pO1xuICBmb3IgKGxldCBkaXJlY3RvcnlFbnRyeU51bWJlciA9IDA7IGRpcmVjdG9yeUVudHJ5TnVtYmVyIDwgaWRmRGlyZWN0b3J5RW50cmllczsgZGlyZWN0b3J5RW50cnlOdW1iZXIrKykge1xuICAgIGNvbnN0IHN0YXJ0ID0gb2Zmc2V0ICsgTlVNX0RJUkVDVE9SWV9FTlRSSUVTX0JZVEVTICsgZGlyZWN0b3J5RW50cnlOdW1iZXIgKiBJREZfRU5UUllfQllURVM7XG4gICAgY29uc3QgZW5kID0gc3RhcnQgKyBJREZfRU5UUllfQllURVM7XG4gICAgaWYgKHN0YXJ0ID4gZXhpZkJsb2NrLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBibG9jayA9IGV4aWZCbG9jay5zbGljZShzdGFydCwgZW5kKTtcbiAgICBjb25zdCB0YWdOdW1iZXIgPSByZWFkVUludChibG9jaywgMTYsIDAsIGlzQmlnRW5kaWFuKTtcbiAgICBpZiAodGFnTnVtYmVyID09PSAyNzQpIHtcbiAgICAgIGNvbnN0IGRhdGFGb3JtYXQgPSByZWFkVUludChibG9jaywgMTYsIDIsIGlzQmlnRW5kaWFuKTtcbiAgICAgIGlmIChkYXRhRm9ybWF0ICE9PSAzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG51bWJlck9mQ29tcG9uZW50cyA9IHJlYWRVSW50KGJsb2NrLCAzMiwgNCwgaXNCaWdFbmRpYW4pO1xuICAgICAgaWYgKG51bWJlck9mQ29tcG9uZW50cyAhPT0gMSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVhZFVJbnQoYmxvY2ssIDE2LCA4LCBpc0JpZ0VuZGlhbik7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUV4aWZCbG9jayhidWZmZXIsIGluZGV4KSB7XG4gIGNvbnN0IGV4aWZCbG9jayA9IGJ1ZmZlci5zbGljZShBUFAxX0RBVEFfU0laRV9CWVRFUywgaW5kZXgpO1xuICBjb25zdCBieXRlQWxpZ24gPSBleGlmQmxvY2sudG9TdHJpbmcoXCJoZXhcIiwgRVhJRl9IRUFERVJfQllURVMsIEVYSUZfSEVBREVSX0JZVEVTICsgVElGRl9CWVRFX0FMSUdOX0JZVEVTKTtcbiAgY29uc3QgaXNCaWdFbmRpYW4gPSBieXRlQWxpZ24gPT09IEJJR19FTkRJQU5fQllURV9BTElHTjtcbiAgY29uc3QgaXNMaXR0bGVFbmRpYW4gPSBieXRlQWxpZ24gPT09IExJVFRMRV9FTkRJQU5fQllURV9BTElHTjtcbiAgaWYgKGlzQmlnRW5kaWFuIHx8IGlzTGl0dGxlRW5kaWFuKSB7XG4gICAgcmV0dXJuIGV4dHJhY3RPcmllbnRhdGlvbihleGlmQmxvY2ssIGlzQmlnRW5kaWFuKTtcbiAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVCdWZmZXIoYnVmZmVyLCBpbmRleCkge1xuICBpZiAoaW5kZXggPiBidWZmZXIubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNvcnJ1cHQgSlBHLCBleGNlZWRlZCBidWZmZXIgbGltaXRzXCIpO1xuICB9XG4gIGlmIChidWZmZXJbaW5kZXhdICE9PSAyNTUpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBKUEcsIG1hcmtlciB0YWJsZSBjb3JydXB0ZWRcIik7XG4gIH1cbn1cbmNvbnN0IEpQRyA9IHtcbiAgdmFsaWRhdGUoYnVmZmVyKSB7XG4gICAgY29uc3QgU09JTWFya2VyID0gYnVmZmVyLnRvU3RyaW5nKFwiaGV4XCIsIDAsIDIpO1xuICAgIHJldHVybiBTT0lNYXJrZXIgPT09IFwiZmZkOFwiO1xuICB9LFxuICBjYWxjdWxhdGUoYnVmZmVyKSB7XG4gICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKDQpO1xuICAgIGxldCBvcmllbnRhdGlvbjtcbiAgICBsZXQgbmV4dDtcbiAgICB3aGlsZSAoYnVmZmVyLmxlbmd0aCkge1xuICAgICAgY29uc3QgaSA9IGJ1ZmZlci5yZWFkVUludDE2QkUoMCk7XG4gICAgICBpZiAoaXNFWElGKGJ1ZmZlcikpIHtcbiAgICAgICAgb3JpZW50YXRpb24gPSB2YWxpZGF0ZUV4aWZCbG9jayhidWZmZXIsIGkpO1xuICAgICAgfVxuICAgICAgdmFsaWRhdGVCdWZmZXIoYnVmZmVyLCBpKTtcbiAgICAgIG5leHQgPSBidWZmZXJbaSArIDFdO1xuICAgICAgaWYgKG5leHQgPT09IDE5MiB8fCBuZXh0ID09PSAxOTMgfHwgbmV4dCA9PT0gMTk0KSB7XG4gICAgICAgIGNvbnN0IHNpemUgPSBleHRyYWN0U2l6ZShidWZmZXIsIGkgKyA1KTtcbiAgICAgICAgaWYgKCFvcmllbnRhdGlvbikge1xuICAgICAgICAgIHJldHVybiBzaXplO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaGVpZ2h0OiBzaXplLmhlaWdodCxcbiAgICAgICAgICBvcmllbnRhdGlvbixcbiAgICAgICAgICB3aWR0aDogc2l6ZS53aWR0aFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKGkgKyAyKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgSlBHLCBubyBzaXplIGZvdW5kXCIpO1xuICB9XG59O1xuXG5jb25zdCBTSUdOQVRVUkUgPSBcIktUWCAxMVwiO1xuY29uc3QgS1RYID0ge1xuICB2YWxpZGF0ZShidWZmZXIpIHtcbiAgICByZXR1cm4gU0lHTkFUVVJFID09PSBidWZmZXIudG9TdHJpbmcoXCJhc2NpaVwiLCAxLCA3KTtcbiAgfSxcbiAgY2FsY3VsYXRlKGJ1ZmZlcikge1xuICAgIHJldHVybiB7XG4gICAgICBoZWlnaHQ6IGJ1ZmZlci5yZWFkVUludDMyTEUoNDApLFxuICAgICAgd2lkdGg6IGJ1ZmZlci5yZWFkVUludDMyTEUoMzYpXG4gICAgfTtcbiAgfVxufTtcblxuY29uc3QgcG5nU2lnbmF0dXJlID0gXCJQTkdcXHJcXG5cdTAwMWFcXG5cIjtcbmNvbnN0IHBuZ0ltYWdlSGVhZGVyQ2h1bmtOYW1lID0gXCJJSERSXCI7XG5jb25zdCBwbmdGcmllZENodW5rTmFtZSA9IFwiQ2dCSVwiO1xuY29uc3QgUE5HID0ge1xuICB2YWxpZGF0ZShidWZmZXIpIHtcbiAgICBpZiAocG5nU2lnbmF0dXJlID09PSBidWZmZXIudG9TdHJpbmcoXCJhc2NpaVwiLCAxLCA4KSkge1xuICAgICAgbGV0IGNodW5rTmFtZSA9IGJ1ZmZlci50b1N0cmluZyhcImFzY2lpXCIsIDEyLCAxNik7XG4gICAgICBpZiAoY2h1bmtOYW1lID09PSBwbmdGcmllZENodW5rTmFtZSkge1xuICAgICAgICBjaHVua05hbWUgPSBidWZmZXIudG9TdHJpbmcoXCJhc2NpaVwiLCAyOCwgMzIpO1xuICAgICAgfVxuICAgICAgaWYgKGNodW5rTmFtZSAhPT0gcG5nSW1hZ2VIZWFkZXJDaHVua05hbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgUE5HXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcbiAgY2FsY3VsYXRlKGJ1ZmZlcikge1xuICAgIGlmIChidWZmZXIudG9TdHJpbmcoXCJhc2NpaVwiLCAxMiwgMTYpID09PSBwbmdGcmllZENodW5rTmFtZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaGVpZ2h0OiBidWZmZXIucmVhZFVJbnQzMkJFKDM2KSxcbiAgICAgICAgd2lkdGg6IGJ1ZmZlci5yZWFkVUludDMyQkUoMzIpXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgaGVpZ2h0OiBidWZmZXIucmVhZFVJbnQzMkJFKDIwKSxcbiAgICAgIHdpZHRoOiBidWZmZXIucmVhZFVJbnQzMkJFKDE2KVxuICAgIH07XG4gIH1cbn07XG5cbmNvbnN0IFBOTVR5cGVzID0ge1xuICBQMTogXCJwYm0vYXNjaWlcIixcbiAgUDI6IFwicGdtL2FzY2lpXCIsXG4gIFAzOiBcInBwbS9hc2NpaVwiLFxuICBQNDogXCJwYm1cIixcbiAgUDU6IFwicGdtXCIsXG4gIFA2OiBcInBwbVwiLFxuICBQNzogXCJwYW1cIixcbiAgUEY6IFwicGZtXCJcbn07XG5jb25zdCBTaWduYXR1cmVzID0gT2JqZWN0LmtleXMoUE5NVHlwZXMpO1xuY29uc3QgaGFuZGxlcnMgPSB7XG4gIGRlZmF1bHQ6IChsaW5lcykgPT4ge1xuICAgIGxldCBkaW1lbnNpb25zID0gW107XG4gICAgd2hpbGUgKGxpbmVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGxpbmUgPSBsaW5lcy5zaGlmdCgpO1xuICAgICAgaWYgKGxpbmVbMF0gPT09IFwiI1wiKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZGltZW5zaW9ucyA9IGxpbmUuc3BsaXQoXCIgXCIpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChkaW1lbnNpb25zLmxlbmd0aCA9PT0gMikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaGVpZ2h0OiBwYXJzZUludChkaW1lbnNpb25zWzFdLCAxMCksXG4gICAgICAgIHdpZHRoOiBwYXJzZUludChkaW1lbnNpb25zWzBdLCAxMClcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIFBOTVwiKTtcbiAgICB9XG4gIH0sXG4gIHBhbTogKGxpbmVzKSA9PiB7XG4gICAgY29uc3Qgc2l6ZSA9IHt9O1xuICAgIHdoaWxlIChsaW5lcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBsaW5lID0gbGluZXMuc2hpZnQoKTtcbiAgICAgIGlmIChsaW5lLmxlbmd0aCA+IDE2IHx8IGxpbmUuY2hhckNvZGVBdCgwKSA+IDEyOCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IGxpbmUuc3BsaXQoXCIgXCIpO1xuICAgICAgaWYgKGtleSAmJiB2YWx1ZSkge1xuICAgICAgICBzaXplW2tleS50b0xvd2VyQ2FzZSgpXSA9IHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gICAgICB9XG4gICAgICBpZiAoc2l6ZS5oZWlnaHQgJiYgc2l6ZS53aWR0aCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNpemUuaGVpZ2h0ICYmIHNpemUud2lkdGgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGhlaWdodDogc2l6ZS5oZWlnaHQsXG4gICAgICAgIHdpZHRoOiBzaXplLndpZHRoXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBQQU1cIik7XG4gICAgfVxuICB9XG59O1xuY29uc3QgUE5NID0ge1xuICB2YWxpZGF0ZShidWZmZXIpIHtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBidWZmZXIudG9TdHJpbmcoXCJhc2NpaVwiLCAwLCAyKTtcbiAgICByZXR1cm4gU2lnbmF0dXJlcy5pbmNsdWRlcyhzaWduYXR1cmUpO1xuICB9LFxuICBjYWxjdWxhdGUoYnVmZmVyKSB7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gYnVmZmVyLnRvU3RyaW5nKFwiYXNjaWlcIiwgMCwgMik7XG4gICAgY29uc3QgdHlwZSA9IFBOTVR5cGVzW3NpZ25hdHVyZV07XG4gICAgY29uc3QgbGluZXMgPSBidWZmZXIudG9TdHJpbmcoXCJhc2NpaVwiLCAzKS5zcGxpdCgvW1xcclxcbl0rLyk7XG4gICAgY29uc3QgaGFuZGxlciA9IGhhbmRsZXJzW3R5cGVdIHx8IGhhbmRsZXJzLmRlZmF1bHQ7XG4gICAgcmV0dXJuIGhhbmRsZXIobGluZXMpO1xuICB9XG59O1xuXG5jb25zdCBQU0QgPSB7XG4gIHZhbGlkYXRlKGJ1ZmZlcikge1xuICAgIHJldHVybiBidWZmZXIudG9TdHJpbmcoXCJhc2NpaVwiLCAwLCA0KSA9PT0gXCI4QlBTXCI7XG4gIH0sXG4gIGNhbGN1bGF0ZShidWZmZXIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaGVpZ2h0OiBidWZmZXIucmVhZFVJbnQzMkJFKDE0KSxcbiAgICAgIHdpZHRoOiBidWZmZXIucmVhZFVJbnQzMkJFKDE4KVxuICAgIH07XG4gIH1cbn07XG5cbmNvbnN0IHN2Z1JlZyA9IC88c3ZnXFxzKFtePlwiJ118XCJbXlwiXSpcInwnW14nXSonKSo+LztcbmNvbnN0IGV4dHJhY3RvclJlZ0V4cHMgPSB7XG4gIGhlaWdodDogL1xcc2hlaWdodD0oWydcIl0pKFteJV0rPylcXDEvLFxuICByb290OiBzdmdSZWcsXG4gIHZpZXdib3g6IC9cXHN2aWV3Qm94PShbJ1wiXSkoLis/KVxcMS8sXG4gIHdpZHRoOiAvXFxzd2lkdGg9KFsnXCJdKShbXiVdKz8pXFwxL1xufTtcbmNvbnN0IElOQ0hfQ00gPSAyLjU0O1xuY29uc3QgdW5pdHMgPSB7XG4gIGNtOiA5NiAvIElOQ0hfQ00sXG4gIGVtOiAxNixcbiAgZXg6IDgsXG4gIG06IDk2IC8gSU5DSF9DTSAqIDEwMCxcbiAgbW06IDk2IC8gSU5DSF9DTSAvIDEwLFxuICBwYzogOTYgLyA3MiAvIDEyLFxuICBwdDogOTYgLyA3MlxufTtcbmZ1bmN0aW9uIHBhcnNlTGVuZ3RoKGxlbikge1xuICBjb25zdCBtID0gLyhbMC05Ll0rKShbYS16XSopLy5leGVjKGxlbik7XG4gIGlmICghbSkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIE1hdGgucm91bmQocGFyc2VGbG9hdChtWzFdKSAqICh1bml0c1ttWzJdXSB8fCAxKSk7XG59XG5mdW5jdGlvbiBwYXJzZVZpZXdib3godmlld2JveCkge1xuICBjb25zdCBib3VuZHMgPSB2aWV3Ym94LnNwbGl0KFwiIFwiKTtcbiAgcmV0dXJuIHtcbiAgICBoZWlnaHQ6IHBhcnNlTGVuZ3RoKGJvdW5kc1szXSksXG4gICAgd2lkdGg6IHBhcnNlTGVuZ3RoKGJvdW5kc1syXSlcbiAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlQXR0cmlidXRlcyhyb290KSB7XG4gIGNvbnN0IHdpZHRoID0gcm9vdC5tYXRjaChleHRyYWN0b3JSZWdFeHBzLndpZHRoKTtcbiAgY29uc3QgaGVpZ2h0ID0gcm9vdC5tYXRjaChleHRyYWN0b3JSZWdFeHBzLmhlaWdodCk7XG4gIGNvbnN0IHZpZXdib3ggPSByb290Lm1hdGNoKGV4dHJhY3RvclJlZ0V4cHMudmlld2JveCk7XG4gIHJldHVybiB7XG4gICAgaGVpZ2h0OiBoZWlnaHQgJiYgcGFyc2VMZW5ndGgoaGVpZ2h0WzJdKSxcbiAgICB2aWV3Ym94OiB2aWV3Ym94ICYmIHBhcnNlVmlld2JveCh2aWV3Ym94WzJdKSxcbiAgICB3aWR0aDogd2lkdGggJiYgcGFyc2VMZW5ndGgod2lkdGhbMl0pXG4gIH07XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVCeURpbWVuc2lvbnMoYXR0cnMpIHtcbiAgcmV0dXJuIHtcbiAgICBoZWlnaHQ6IGF0dHJzLmhlaWdodCxcbiAgICB3aWR0aDogYXR0cnMud2lkdGhcbiAgfTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZUJ5Vmlld2JveChhdHRycywgdmlld2JveCkge1xuICBjb25zdCByYXRpbyA9IHZpZXdib3gud2lkdGggLyB2aWV3Ym94LmhlaWdodDtcbiAgaWYgKGF0dHJzLndpZHRoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhlaWdodDogTWF0aC5mbG9vcihhdHRycy53aWR0aCAvIHJhdGlvKSxcbiAgICAgIHdpZHRoOiBhdHRycy53aWR0aFxuICAgIH07XG4gIH1cbiAgaWYgKGF0dHJzLmhlaWdodCkge1xuICAgIHJldHVybiB7XG4gICAgICBoZWlnaHQ6IGF0dHJzLmhlaWdodCxcbiAgICAgIHdpZHRoOiBNYXRoLmZsb29yKGF0dHJzLmhlaWdodCAqIHJhdGlvKVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBoZWlnaHQ6IHZpZXdib3guaGVpZ2h0LFxuICAgIHdpZHRoOiB2aWV3Ym94LndpZHRoXG4gIH07XG59XG5jb25zdCBTVkcgPSB7XG4gIHZhbGlkYXRlKGJ1ZmZlcikge1xuICAgIGNvbnN0IHN0ciA9IFN0cmluZyhidWZmZXIpO1xuICAgIHJldHVybiBzdmdSZWcudGVzdChzdHIpO1xuICB9LFxuICBjYWxjdWxhdGUoYnVmZmVyKSB7XG4gICAgY29uc3Qgcm9vdCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIikubWF0Y2goZXh0cmFjdG9yUmVnRXhwcy5yb290KTtcbiAgICBpZiAocm9vdCkge1xuICAgICAgY29uc3QgYXR0cnMgPSBwYXJzZUF0dHJpYnV0ZXMocm9vdFswXSk7XG4gICAgICBpZiAoYXR0cnMud2lkdGggJiYgYXR0cnMuaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiBjYWxjdWxhdGVCeURpbWVuc2lvbnMoYXR0cnMpO1xuICAgICAgfVxuICAgICAgaWYgKGF0dHJzLnZpZXdib3gpIHtcbiAgICAgICAgcmV0dXJuIGNhbGN1bGF0ZUJ5Vmlld2JveChhdHRycywgYXR0cnMudmlld2JveCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIFNWR1wiKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gY2FsY3VsYXRlRXh0ZW5kZWQoYnVmZmVyKSB7XG4gIHJldHVybiB7XG4gICAgaGVpZ2h0OiAxICsgYnVmZmVyLnJlYWRVSW50TEUoNywgMyksXG4gICAgd2lkdGg6IDEgKyBidWZmZXIucmVhZFVJbnRMRSg0LCAzKVxuICB9O1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlTG9zc2xlc3MoYnVmZmVyKSB7XG4gIHJldHVybiB7XG4gICAgaGVpZ2h0OiAxICsgKChidWZmZXJbNF0gJiAxNSkgPDwgMTAgfCBidWZmZXJbM10gPDwgMiB8IChidWZmZXJbMl0gJiAxOTIpID4+IDYpLFxuICAgIHdpZHRoOiAxICsgKChidWZmZXJbMl0gJiA2MykgPDwgOCB8IGJ1ZmZlclsxXSlcbiAgfTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZUxvc3N5KGJ1ZmZlcikge1xuICByZXR1cm4ge1xuICAgIGhlaWdodDogYnVmZmVyLnJlYWRJbnQxNkxFKDgpICYgMTYzODMsXG4gICAgd2lkdGg6IGJ1ZmZlci5yZWFkSW50MTZMRSg2KSAmIDE2MzgzXG4gIH07XG59XG5jb25zdCBXRUJQID0ge1xuICB2YWxpZGF0ZShidWZmZXIpIHtcbiAgICBjb25zdCByaWZmSGVhZGVyID0gYnVmZmVyLnRvU3RyaW5nKFwiYXNjaWlcIiwgMCwgNCkgPT09IFwiUklGRlwiO1xuICAgIGNvbnN0IHdlYnBIZWFkZXIgPSBidWZmZXIudG9TdHJpbmcoXCJhc2NpaVwiLCA4LCAxMikgPT09IFwiV0VCUFwiO1xuICAgIGNvbnN0IHZwOEhlYWRlciA9IGJ1ZmZlci50b1N0cmluZyhcImFzY2lpXCIsIDEyLCAxNSkgPT09IFwiVlA4XCI7XG4gICAgcmV0dXJuIHJpZmZIZWFkZXIgJiYgd2VicEhlYWRlciAmJiB2cDhIZWFkZXI7XG4gIH0sXG4gIGNhbGN1bGF0ZShidWZmZXIpIHtcbiAgICBjb25zdCBjaHVua0hlYWRlciA9IGJ1ZmZlci50b1N0cmluZyhcImFzY2lpXCIsIDEyLCAxNik7XG4gICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKDIwLCAzMCk7XG4gICAgaWYgKGNodW5rSGVhZGVyID09PSBcIlZQOFhcIikge1xuICAgICAgY29uc3QgZXh0ZW5kZWRIZWFkZXIgPSBidWZmZXJbMF07XG4gICAgICBjb25zdCB2YWxpZFN0YXJ0ID0gKGV4dGVuZGVkSGVhZGVyICYgMTkyKSA9PT0gMDtcbiAgICAgIGNvbnN0IHZhbGlkRW5kID0gKGV4dGVuZGVkSGVhZGVyICYgMSkgPT09IDA7XG4gICAgICBpZiAodmFsaWRTdGFydCAmJiB2YWxpZEVuZCkge1xuICAgICAgICByZXR1cm4gY2FsY3VsYXRlRXh0ZW5kZWQoYnVmZmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIFdlYlBcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjaHVua0hlYWRlciA9PT0gXCJWUDggXCIgJiYgYnVmZmVyWzBdICE9PSA0Nykge1xuICAgICAgcmV0dXJuIGNhbGN1bGF0ZUxvc3N5KGJ1ZmZlcik7XG4gICAgfVxuICAgIGNvbnN0IHNpZ25hdHVyZSA9IGJ1ZmZlci50b1N0cmluZyhcImhleFwiLCAzLCA2KTtcbiAgICBpZiAoY2h1bmtIZWFkZXIgPT09IFwiVlA4TFwiICYmIHNpZ25hdHVyZSAhPT0gXCI5ZDAxMmFcIikge1xuICAgICAgcmV0dXJuIGNhbGN1bGF0ZUxvc3NsZXNzKGJ1ZmZlcik7XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIFdlYlBcIik7XG4gIH1cbn07XG5cbmNvbnN0IHR5cGVIYW5kbGVycyA9IHtcbiAgYm1wOiBCTVAsXG4gIGN1cjogQ1VSLFxuICBkZHM6IEREUyxcbiAgZ2lmOiBHSUYsXG4gIGljbnM6IElDTlMsXG4gIGljbzogSUNPLFxuICBqMmM6IEoyQyxcbiAganAyOiBKUDIsXG4gIGpwZzogSlBHLFxuICBrdHg6IEtUWCxcbiAgcG5nOiBQTkcsXG4gIHBubTogUE5NLFxuICBwc2Q6IFBTRCxcbiAgc3ZnOiBTVkcsXG4gIHdlYnA6IFdFQlBcbn07XG5jb25zdCBnZXRNaW1lVHlwZSA9ICh0eXBlKSA9PiB7XG4gIGlmICh0eXBlID09PSBcInN2Z1wiKSB7XG4gICAgcmV0dXJuIFwiaW1hZ2Uvc3ZnK3htbFwiO1xuICB9XG4gIHJldHVybiBgaW1hZ2UvJHt0eXBlfWA7XG59O1xuXG5jb25zdCBrZXlzID0gT2JqZWN0LmtleXModHlwZUhhbmRsZXJzKTtcbmNvbnN0IGZpcnN0Qnl0ZXMgPSB7XG4gIDU2OiBcInBzZFwiLFxuICA2NjogXCJibXBcIixcbiAgNjg6IFwiZGRzXCIsXG4gIDcxOiBcImdpZlwiLFxuICA3MzogXCJ0aWZmXCIsXG4gIDc3OiBcInRpZmZcIixcbiAgODI6IFwid2VicFwiLFxuICAxMDU6IFwiaWNuc1wiLFxuICAxMzc6IFwicG5nXCIsXG4gIDI1NTogXCJqcGdcIlxufTtcbmZ1bmN0aW9uIGRldGVjdG9yKGJ1ZmZlcikge1xuICBjb25zdCBieXRlID0gYnVmZmVyWzBdO1xuICBpZiAoYnl0ZSBpbiBmaXJzdEJ5dGVzKSB7XG4gICAgY29uc3QgdHlwZSA9IGZpcnN0Qnl0ZXNbYnl0ZV07XG4gICAgaWYgKHR5cGVIYW5kbGVyc1t0eXBlXS52YWxpZGF0ZShidWZmZXIpKSB7XG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZmluZGVyID0gKGtleSkgPT4gdHlwZUhhbmRsZXJzW2tleV0udmFsaWRhdGUoYnVmZmVyKTtcbiAgcmV0dXJuIGtleXMuZmluZChmaW5kZXIpO1xufVxuXG5mdW5jdGlvbiBsb29rdXAoYnVmZmVyLCBmaWxlcGF0aCkge1xuICBjb25zdCB0eXBlID0gZGV0ZWN0b3IoYnVmZmVyKTtcbiAgaWYgKHR5cGUgJiYgdHlwZSBpbiB0eXBlSGFuZGxlcnMpIHtcbiAgICBjb25zdCBzaXplID0gdHlwZUhhbmRsZXJzW3R5cGVdLmNhbGN1bGF0ZShidWZmZXIsIGZpbGVwYXRoKTtcbiAgICBpZiAoc2l6ZSAhPT0gdm9pZCAwKSB7XG4gICAgICBzaXplLnR5cGUgPSB0eXBlO1xuICAgICAgc2l6ZS5taW1lVHlwZSA9IGdldE1pbWVUeXBlKHR5cGUpO1xuICAgICAgcmV0dXJuIHNpemU7XG4gICAgfVxuICB9XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJ1bnN1cHBvcnRlZCBmaWxlIHR5cGU6IFwiICsgdHlwZSArIFwiIChmaWxlOiBcIiArIGZpbGVwYXRoICsgXCIpXCIpO1xufVxuZnVuY3Rpb24gaW1hZ2VNZXRhKGlucHV0KSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoaW5wdXQpKSB7XG4gICAgcmV0dXJuIGxvb2t1cChpbnB1dCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgc2hvdWxkIGJlIGJ1ZmZlciFcIik7XG59XG5jb25zdCB0eXBlcyA9IE9iamVjdC5rZXlzKHR5cGVIYW5kbGVycyk7XG5cbmV4cG9ydCB7IGltYWdlTWV0YSwgdHlwZXMgfTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/image-meta/dist/index.mjs\n");

/***/ })

}]);